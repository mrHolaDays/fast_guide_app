{
    "JavaScript": {
      "Core Concepts": {
        "Variables": "Именованные контейнеры для хранения данных.  Переменные позволяют хранить значения, которые могут меняться в процессе выполнения программы.  Объявляются с помощью `var`, `let`, `const`.  Выбор типа объявления влияет на область видимости и возможность изменения значения.  Правильные имена переменных делают код более читаемым и понятным.  Примеры: `let age = 30;`, `const PI = 3.14159;`, `var name = 'John Doe';`.",
        "Data Types": "Типы данных, которые может хранить переменная. JavaScript – язык с динамической типизацией, то есть тип переменной определяется во время выполнения, а не при объявлении. Важно понимать, какие типы данных доступны, чтобы правильно использовать их и избежать ошибок.  Основные типы данных: `number`, `string`, `boolean`, `null`, `undefined`, `symbol`, `bigint`, `object` (включая `array`, `function`, `date`, `RegExp`).  Примеры: `let count = 10;` (number), `let message = 'Hello';` (string), `let isEnabled = true;` (boolean), `let user = null;` (null), `let result;` (undefined).",
        "Operators": "Символы, выполняющие операции над данными. Операторы позволяют выполнять различные действия с переменными и значениями, такие как арифметические вычисления, сравнения, логические операции и присваивание.  Типы операторов: арифметические (`+`, `-`, `*`, `/`, `%`, `**`), присваивания (`=`, `+=`, `-=`, `*=`, `/=`, `%=`, `**=`, `<<=`, `>>=`, `>>>=`, `&=`, `|=`, `^=`), сравнения (`==`, `===`, `!=`, `!==`, `>`, `<`, `>=`, `<=`), логические (`&&`, `||`, `!`), побитовые (`&`, `|`, `^`, `~`, `<<`, `>>`, `>>>`), условный (тернарный) оператор (`? :`), оператор `typeof`, оператор `instanceof`, оператор `in`, оператор `void`.  Примеры: `let sum = 5 + 3;`, `if (age > 18) { ... }`, `let isAdult = age >= 18 ? true : false;`.",
        "Control Flow": "Управление порядком выполнения кода. Конструкции управления потоком позволяют изменять порядок выполнения инструкций в зависимости от определенных условий или повторять выполнение блока кода несколько раз.  Типы конструкций: `if`, `else if`, `else`, `switch`, `for`, `while`, `do...while`, `break`, `continue`, `return`.  Примеры: `if (isLoggedIn) { showDashboard(); } else { showLoginForm(); }`, `for (let i = 0; i < 10; i++) { console.log(i); }`, `while (count > 0) { ... count--; }`.",
        "Functions": "Блоки кода, выполняющие определенную задачу. Функции позволяют организовать код в логические блоки, которые можно повторно использовать.  Функции могут принимать аргументы (входные данные) и возвращать значения (результат выполнения).  Объявляются с помощью `function`, стрелочных функций (`=>`).  Примеры: `function add(a, b) { return a + b; }`, `const multiply = (a, b) => a * b;`.",
        "Objects": "Коллекции свойств (ключ-значение). Объекты позволяют хранить структурированные данные, состоящие из свойств (ключей) и их значений.  Свойства могут содержать любые типы данных, включая другие объекты и функции (методы).  Создаются с помощью `{}`. Доступ к свойствам через точку (`.`) или квадратные скобки (`[]`). Примеры: `const user = { name: 'John', age: 30, city: 'New York' };`, `console.log(user.name);`, `console.log(user['age']);`.",
        "Arrays": "Упорядоченные списки элементов. Массивы позволяют хранить упорядоченные коллекции элементов одного или разных типов данных. Создаются с помощью `[]`. Доступ к элементам по индексу (начиная с 0). Примеры: `const numbers = [1, 2, 3, 4, 5];`, `console.log(numbers[0]);` (выводит 1), `numbers.push(6);` (добавляет 6 в конец массива).",
        "Scope": "Область видимости переменной.  Область видимости определяет, где в коде можно получить доступ к переменной.  Типы областей видимости: глобальная (доступна везде), функциональная (внутри функции), блочная (внутри блока кода `{}`).",
        "Hoisting": "Механизм, при котором объявления переменных (с `var`) и функций перемещаются вверх области видимости во время компиляции (но не инициализация). Это может привести к неожиданному поведению, если не учитывать этот механизм.  `let` и `const` не подвержены hoisting, хотя их объявления также перемещаются вверх, но они не могут быть использованы до их объявления в коде (temporal dead zone).",
        "Closures": "Функция, которая имеет доступ к переменным внешней (родительской) функции, даже после того, как внешняя функция завершила свое выполнение. Closures позволяют создавать приватные переменные и функции.",
        "This Keyword": "Ключевое слово, которое ссылается на объект, в контексте которого выполняется код.  Значение `this` зависит от того, как вызывается функция.  В глобальном контексте `this` ссылается на глобальный объект (window в браузере, global в Node.js).  В методах объекта `this` ссылается на сам объект.  В конструкторах `this` ссылается на новый создаваемый объект.",
        "Prototypal Inheritance": "Механизм наследования в JavaScript.  Объекты наследуют свойства и методы от своих прототипов.  Каждый объект имеет свойство `__proto__`, которое ссылается на его прототип.  Можно создавать цепочки прототипов для реализации сложного наследования.",
        "First-Class Functions": "Функции в JavaScript являются объектами первого класса, то есть их можно передавать в качестве аргументов в другие функции, возвращать из функций и присваивать переменным."
      },
      "Variables and Data Types": {
        "Declaration": "Объявление переменной. Создание переменной с определенным именем. Примеры: `var x;`, `let y;`, `const z = 10;`.  При объявлении переменной с `var` ей автоматически присваивается значение `undefined`.  `let` и `const` не присваивают значение автоматически, поэтому обращение к ним до инициализации вызовет ошибку (temporal dead zone).",
        "Initialization": "Присваивание значения переменной. Инициализация переменной задает ей начальное значение.  Примеры: `x = 5;`, `y = "Hello";`.",
        "var": "Объявление переменной с функциональной или глобальной областью видимости.  `var` имеет область видимости функции, то есть переменная, объявленная с помощью `var` внутри функции, будет видна только внутри этой функции (или во вложенных функциях).  Если `var` объявлена вне какой-либо функции, она становится глобальной переменной и доступна из любого места в коде. Подвержена hoisting.",
        "let": "Объявление переменной с блочной областью видимости.  `let` имеет блочную область видимости, то есть переменная видна только внутри блока кода, в котором она объявлена (например, внутри `if`, `for`, `while`). Не подвержена hoisting (temporal dead zone).",
        "const": "Объявление константы с блочной областью видимости.  `const` также имеет блочную область видимости, как и `let`.  После инициализации константы ее значение нельзя изменить.  Для объектов и массивов, объявленных как `const`, можно изменять их свойства и элементы, но нельзя переназначить саму переменную (то есть нельзя присвоить ей другой объект или массив).",
        "Number": "Числовой тип данных.  Представляет числовые значения, включая целые числа, числа с плавающей точкой, а также специальные значения `NaN` (Not a Number), `Infinity` и `-Infinity`. JavaScript использует 64-битный формат с плавающей точкой (double-precision floating-point format) для представления чисел.",
        "String": "Текстовый тип данных.  Представляет последовательность символов.  Строки в JavaScript являются неизменяемыми, то есть после создания строки ее нельзя изменить.  Для работы со строками используются различные методы, такие как `slice()`, `substring()`, `replace()`, `toUpperCase()`, `toLowerCase()`, `trim()`.",
        "Boolean": "Логический тип данных.  Представляет логические значения `true` (истина) или `false` (ложь).  Используется в условных выражениях и логических операциях.",
        "Null": "Представляет отсутствие значения.  Используется для явного указания на то, что переменная не содержит никакого значения.",
        "Undefined": "Переменная объявлена, но не инициализирована.  Если переменной не присвоено значение, она имеет значение `undefined`.  Также возвращается при обращении к несуществующему свойству объекта.",
        "Symbol": "Уникальный и неизменяемый тип данных (введен в ES6). Используется для создания уникальных идентификаторов свойств объектов.  Символы не видны при перечислении свойств объекта с помощью `for...in` или `Object.keys()`.",
        "BigInt": "Целые числа произвольной длины (введен в ES2020).  Используется для представления целых чисел, которые превышают максимальное значение, которое может быть безопасно представлено типом `Number` (Number.MAX_SAFE_INTEGER).",
        "Object": "Комплексный тип данных, представляющий собой коллекцию свойств (ключ-значение).  Объекты являются основными строительными блоками JavaScript.  Могут содержать любые типы данных, включая другие объекты и функции (методы).",
         "typeof Operator": "Возвращает тип переменной в виде строки. Используется для проверки типа данных переменной. Примеры: `typeof 10` (возвращает 'number'), `typeof 'hello'` (возвращает 'string'), `typeof true` (возвращает 'boolean'), `typeof null` (возвращает 'object' - историческая ошибка), `typeof undefined` (возвращает 'undefined'), `typeof {}` (возвращает 'object'), `typeof []` (возвращает 'object'), `typeof function() {}` (возвращает 'function')."
      },
      "Operators": {
        "Arithmetic": "+ (сложение).  Возвращает сумму двух операндов. Если один из операндов является строкой, выполняется конкатенация строк. - (вычитание).  Возвращает разность двух операндов. * (умножение). Возвращает произведение двух операндов. / (деление). Возвращает частное двух операндов. % (остаток от деления). Возвращает остаток от деления первого операнда на второй. ** (возведение в степень). Возвращает первый операнд, возведенный в степень второго операнда.",
        "Assignment": "= (присваивание).  Присваивает значение правого операнда левому операнду. += (сложение и присваивание). Складывает правый операнд с левым и присваивает результат левому операнду. -= (вычитание и присваивание).  Вычитает правый операнд из левого и присваивает результат левому операнду. *= (умножение и присваивание).  Умножает правый операнд на левый и присваивает результат левому операнду. /= (деление и присваивание).  Делит левый операнд на правый и присваивает результат левому операнду. %= (остаток от деления и присваивание). Возвращает остаток от деления первого операнда на второй и присваивает результат левому операнду. **= (возведение в степень и присваивание). Возводит левый операнд в степень правого и присваивает результат левому операнду.",
        "Comparison": "== (равно по значению).  Сравнивает два операнда на равенство после приведения типов.  Используйте `===` для более строгого сравнения. === (равно по значению и типу). Сравнивает два операнда на равенство без приведения типов.  Рекомендуется использовать `===` для предотвращения неожиданного поведения. != (не равно по значению).  Сравнивает два операнда на неравенство после приведения типов.  Используйте `!==` для более строгого сравнения. !== (не равно по значению и типу). Сравнивает два операнда на неравенство без приведения типов. > (больше). Сравнивает, является ли первый операнд больше второго. < (меньше). Сравнивает, является ли первый операнд меньше второго. >= (больше или равно). Сравнивает, является ли первый операнд больше или равен второму. <= (меньше или равно). Сравнивает, является ли первый операнд меньше или равен второму.",
        "Logical": "&& (логическое И). Возвращает `true`, если оба операнда истинны. || (логическое ИЛИ).  Возвращает `true`, если хотя бы один из операндов истинен. ! (логическое НЕ). Возвращает `true`, если операнд ложен, и `false`, если операнд истинен.",
        "Unary": "+ (унарный плюс).  Пытается преобразовать операнд в число. - (унарный минус). Пытается преобразовать операнд в число и меняет его знак. ++ (инкремент). Увеличивает значение операнда на 1. Может быть префиксным (`++x`) или постфиксным (`x++`). -- (декремент). Уменьшает значение операнда на 1. Может быть префиксным (`--x`) или постфиксным (`x--`).",
        "Ternary": "Условный оператор `condition ? expr1 : expr2`.  Сокращенная форма для написания `if...else` выражений.  Если `condition` истинно, возвращает `expr1`, иначе возвращает `expr2`.",
        "Bitwise": "& (побитовое И). Выполняет побитовую операцию И над двумя операндами. | (побитовое ИЛИ). Выполняет побитовую операцию ИЛИ над двумя операндами. ^ (побитовое исключающее ИЛИ). Выполняет побитовую операцию исключающее ИЛИ над двумя операндами. ~ (побитовое НЕ). Выполняет побитовую операцию НЕ над операндом. << (побитовый сдвиг влево). Сдвигает биты первого операнда влево на количество позиций, указанное вторым операндом. >> (побитовый сдвиг вправо). Сдвигает биты первого операнда вправо на количество позиций, указанное вторым операндом, сохраняя знак. >>> (побитовый сдвиг вправо с заполнением нулями). Сдвигает биты первого операнда вправо на количество позиций, указанное вторым операндом, заполняя нулями."
      },
      "Control Flow": {
        "if...else": "Условное выполнение кода.  Позволяет выполнить блок кода, если условие истинно, и другой блок кода (если есть), если условие ложно.  `if (condition) { ... } else { ... }`.  `else` может быть опущен, если не нужно выполнять код при ложном условии.",
        "else if": "Дополнительные условия.  Позволяет проверить несколько условий последовательно.  `if (condition1) { ... } else if (condition2) { ... } else { ... }`.  Выполняется только один блок кода, соответствующий первому истинному условию.  Последний `else` является необязательным.",
        "switch": "Выбор из нескольких вариантов.  Позволяет выбрать один из нескольких вариантов выполнения кода в зависимости от значения выражения. `switch (expression) { case value1: ... break; case value2: ... break; default: ... }`.  `break` необходим для предотвращения fall-through (выполнения кода следующих case'ов). `default` – необязательный блок, который выполняется, если ни один из `case` не соответствует выражению.",
        "for": "Цикл с заданным количеством итераций.  Позволяет повторить выполнение блока кода заданное количество раз.  `for (initialization; condition; increment/decrement) { ... }`.  `initialization` – выполняется один раз перед началом цикла. `condition` – проверяется перед каждой итерацией цикла. Если условие истинно, цикл продолжается. Если ложно, цикл завершается. `increment/decrement` – выполняется после каждой итерации цикла. Обычно используется для изменения счетчика.",
        "while": "Цикл, выполняющийся до тех пор, пока условие истинно.  Позволяет повторить выполнение блока кода до тех пор, пока условие остается истинным.  `while (condition) { ... }`.  Условие проверяется перед каждой итерацией цикла.  Если условие изначально ложно, цикл не выполнится ни разу.",
        "do...while": "Цикл, выполняющийся как минимум один раз, а затем продолжающийся, пока условие истинно.  `do { ... } while (condition);`. Блок кода выполняется как минимум один раз, даже если условие изначально ложно.  Условие проверяется после каждой итерации цикла.",
        "break": "Прерывает выполнение цикла или `switch`.  Позволяет немедленно завершить выполнение цикла (`for`, `while`, `do...while`) или `switch`, независимо от того, выполнено ли условие цикла или все `case`'ы `switch`.",
        "continue": "Переходит к следующей итерации цикла, пропуская оставшуюся часть текущей итерации. Позволяет пропустить выполнение части кода в текущей итерации цикла и перейти к следующей итерации, без завершения цикла."
      },
      "Functions": {
        "Declaration": "Объявление функции.  Создание функции с определенным именем.  `function myFunction(arg1, arg2) { ... return value; }`.  Функции, объявленные таким образом, подвержены hoisting.",
        "Expression": "Функциональное выражение.  Присваивание функции переменной.  `const myFunction = function(arg1, arg2) { ... return value; }`.  Функциональные выражения не подвержены hoisting, если используются `let` или `const`.",
        "Arrow Functions": "Стрелочные функции (ES6).  Сокращенный синтаксис для определения функций. `const myFunction = (arg1, arg2) => { ... return value; }` или `const myFunction = arg => arg * 2;` (если один аргумент и одна строка кода). Стрелочные функции не имеют собственного `this` (используют `this` внешней функции).",
        "Arguments": "Значения, передаваемые в функцию при вызове.  Функции могут принимать любое количество аргументов, даже если при объявлении функции указано другое количество параметров.  Непереданные аргументы получают значение `undefined`.  Доступны через псевдомассив `arguments` (в обычных функциях, устаревший) или как именованные параметры.",
        "Return Value": "Значение, возвращаемое функцией с помощью оператора `return`.  Если `return` отсутствует, функция возвращает `undefined`.  Оператор `return` завершает выполнение функции.",
        "Scope and Closures": "Функции создают свою область видимости.  Переменные, объявленные внутри функции, не видны за ее пределами (если только не используются closures).  Вложенные функции имеют доступ к переменным внешней функции (closure).",
        "IIFE (Immediately Invoked Function Expression)": "Функция, которая вызывается сразу после ее определения.  `(function() { ... })();` или `(() => { ... })();`.  Используется для создания изолированной области видимости, чтобы избежать конфликтов имен с глобальными переменными.",
        "Default Parameters": "Значения по умолчанию для параметров функции, если они не переданы при вызове.  `function myFunction(arg1 = 10, arg2 = "default") { ... }`.  Параметры со значениями по умолчанию должны быть указаны в конце списка параметров.",
        "Rest Parameters": "Позволяет функции принимать неопределенное количество аргументов в виде массива. `function myFunction(...args) { ... }`.  Rest parameter должен быть последним параметром в списке параметров.",
        "Generator Functions": "Функции, которые могут приостанавливать и возобновлять свое выполнение (с использованием `yield`).  Используются для создания итераторов.  `function* myGenerator() { yield 1; yield 2; }`.  Вызов генераторной функции возвращает объект итератора.",
        "Higher-Order Functions": "Функции, которые принимают другие функции в качестве аргументов или возвращают другие функции в качестве результатов.  Примеры: `map()`, `filter()`, `reduce()`, `forEach()`, `setTimeout()`, `addEventListener()`."
      },
      "Objects": {
        "Creation": "Создание объекта.  `const myObject = { key1: "value1", key2: 20 };` или `const myObject = new Object(); myObject.key1 = "value1"; myObject.key2 = 20;`. Также можно использовать `Object.create()` для создания объектов с прототипом.",
        "Properties": "Свойства объекта (ключ-значение).  Ключи – строки или символы.  Значения могут быть любых типов данных.",
        "Access": "Доступ к свойствам.  `myObject.key1` (через точку) или `myObject['key1']` (через квадратные скобки).  Квадратные скобки позволяют использовать переменные для доступа к свойствам.",
        "Methods": "Функции, являющиеся свойствами объекта.  `const myObject = { myMethod: function() { ... } };`.",
        "this": "Ключевое слово, ссылающееся на текущий объект. В контексте метода объекта, `this` ссылается на сам объект.  Вне объектов, `this` обычно ссылается на глобальный объект (window в браузере, global в Node.js).  В стрелочных функциях `this` сохраняет значение из внешней области видимости.",
        "Constructor Functions": "Функции, используемые для создания объектов (с помощью оператора `new`). `function MyObject(arg1, arg2) { this.key1 = arg1; this.key2 = arg2; } const obj = new MyObject("value1", 20);`.  Конструкторные функции создают объекты с общим прототипом.",
        "Classes": "Синтаксический сахар над прототипным наследованием (ES6).  `class MyClass { constructor(arg1, arg2) { this.key1 = arg1; this.key2 = arg2; } myMethod() { ... } } const obj = new MyClass("value1", 20);`.  Классы упрощают создание объектов и управление наследованием.",
        "Object.create()": "Метод для создания нового объекта с указанным прототипом и свойствами.  Позволяет создавать объекты, которые наследуют свойства и методы от другого объекта.",
         "Object.keys()": "Метод для получения массива ключей объекта. Возвращает массив строк, представляющих ключи объекта.",
         "Object.values()": "Метод для получения массива значений объекта. Возвращает массив значений свойств объекта.",
         "Object.entries()": "Метод для получения массива пар ключ-значение объекта. Возвращает массив массивов, где каждый внутренний массив содержит ключ и значение свойства.",
         "Object.assign()": "Метод для копирования значений всех собственных перечисляемых свойств из одного или нескольких исходных объектов в целевой объект. Возвращает целевой объект."
      },
      "Arrays": {
        "Creation": "Создание массива. `const myArray = [1, 2, "hello"];` или `const myArray = new Array(1, 2, "hello");`.  Рекомендуется использовать литеральную запись массива `[]`.",
        "Access": "Доступ к элементам.  `myArray[0]` (индекс начинается с 0).  Обращение к элементу по несуществующему индексу возвращает `undefined`.",
        "Length": "Свойство, возвращающее длину массива. `myArray.length`.  Можно использовать `length` для изменения размера массива (усечения или добавления пустых элементов).",
        "Methods": "Методы для работы с массивами. `push()`, `pop()`, `shift()`, `unshift()`, `splice()`, `slice()`, `concat()`, `join()`, `indexOf()`, `lastIndexOf()`, `includes()`, `find()`, `findIndex()`, `filter()`, `map()`, `reduce()`, `forEach()`, `sort()`, `reverse()`.",
        "forEach()": "Выполняет указанную функцию один раз для каждого элемента в массиве. Не возвращает новый массив. Используется для выполнения побочных эффектов.",
        "map()": "Создает новый массив с результатами вызова указанной функции для каждого элемента в исходном массиве. Используется для преобразования элементов массива.",
        "filter()": "Создает новый массив со всеми элементами, прошедшими проверку, заданную в передаваемой функции. Используется для выбора элементов из массива.",
        "reduce()": "Применяет функцию к аккумулятору и каждому элементу массива (слева направо), сводя его к одному значению. Используется для вычисления агрегированных значений (суммы, среднего и т.д.).",
        "Spread Operator (...)": "Позволяет расширить массив в местах, где ожидается несколько аргументов или элементов.  Примеры: `const newArray = [...myArray, 4, 5];`, `myFunction(...myArray);`.",
        "Destructuring Assignment": "Позволяет извлечь значения из массива и присвоить их переменным.  `const [first, second, ...rest] = myArray;`."
      },
      "Strings": {
        "Creation": "Создание строки. `const myString = "Hello";` или `const myString = new String("Hello");`. Рекомендуется использовать литеральную запись строки `""` или ``",
        "Length": "Свойство, возвращающее длину строки.  `myString.length`.",
        "Methods": "Методы для работы со строками. `charAt()`, `charCodeAt()`, `concat()`, `indexOf()`, `lastIndexOf()`, `slice()`, `substring()`, `substr()`, `replace()`, `toUpperCase()`, `toLowerCase()`, `trim()`, `split()`.",
        "Template Literals": "Шаблонные литералы (ES6).  Позволяют встраивать выражения в строки.  `const name = "World"; const greeting = `Hello, ${name}!``.",
        "String.prototype.startsWith()": "Проверяет, начинается ли строка с указанной подстроки.",
        "String.prototype.endsWith()": "Проверяет, заканчивается ли строка указанной подстрокой.",
        "String.prototype.includes()": "Проверяет, содержит ли строка указанную подстроку."
      },
      "Dates": {
        "Creation": "Создание объекта Date.  `const myDate = new Date();` (текущая дата и время), `const myDate = new Date(2023, 10, 20);` (20 ноября 2023 - месяцы начинаются с 0), `const myDate = new Date("2023-11-20");` (строковое представление).",
        "Methods": "Методы для работы с датами. `getFullYear()`, `getMonth()`, `getDate()`, `getHours()`, `getMinutes()`, `getSeconds()`, `getMilliseconds()`, `getTime()` (количество миллисекунд с 1 января 1970 года), `toLocaleDateString()`, `toLocaleTimeString()`, `toISOString()`.",
        "Date.now()": "Возвращает количество миллисекунд, прошедших с 1 января 1970 года до текущего момента.",
        "Formatting Dates": "Для форматирования дат можно использовать библиотеку `Moment.js` (устаревшая, рекомендуются альтернативы) или `Intl.DateTimeFormat` (встроенный объект)."
      },
       "DOM Manipulation": {
          "Document Object Model (DOM)": "Представление HTML-документа в виде древовидной структуры.  JavaScript может использовать DOM для доступа и изменения содержимого, структуры и стиля HTML-страницы. DOM API позволяет динамически обновлять веб-страницы.",
          "Selecting Elements": "Методы для выбора HTML-элементов.  `document.getElementById(id)` - выбирает элемент по ID (быстрый, но ID должен быть уникальным). `document.getElementsByClassName(className)` - выбирает все элементы с указанным классом (возвращает HTMLCollection). `document.getElementsByTagName(tagName)` - выбирает все элементы с указанным тегом (возвращает HTMLCollection). `document.querySelector(selector)` - выбирает первый элемент, соответствующий CSS-селектору. `document.querySelectorAll(selector)` - выбирает все элементы, соответствующие CSS-селектору (возвращает NodeList).  `querySelector()` и `querySelectorAll()` принимают CSS-селекторы, что делает их более гибкими.",
          "Creating Elements": "Методы для создания новых HTML-элементов.  `document.createElement(tagName)` - создает новый элемент с указанным тегом. `document.createTextNode(text)` - создает новый текстовый узел.",
          "Adding and Removing Elements": "Методы для добавления и удаления элементов. `appendChild(node)` - добавляет узел в конец родительского элемента. `insertBefore(newNode, existingNode)` - добавляет новый узел перед существующим узлом. `removeChild(node)` - удаляет узел из родительского элемента. `replaceChild(newNode, oldNode)` - заменяет существующий узел новым узлом.",
          "Modifying Attributes": "Методы для изменения атрибутов элементов. `getAttribute(attributeName)` - получает значение атрибута. `setAttribute(attributeName, value)` - устанавливает значение атрибута. `removeAttribute(attributeName)` - удаляет атрибут. Также можно напрямую обращаться к атрибутам элемента как к свойствам объекта (например, `element.src = "image.jpg";`).",
          "Modifying Styles": "Изменение стилей элемента. `element.style.property = value;` (например, `element.style.color = "red";`). Рекомендуется использовать классы CSS для управления стилями, так как это улучшает организацию кода и позволяет легко изменять стили. Можно добавлять и удалять классы с помощью `element.classList.add(className)`, `element.classList.remove(className)`, `element.classList.toggle(className)`.  Использование CSS-классов упрощает поддержку и позволяет применять стили к нескольким элементам одновременно.",
          "Event Listeners": "Методы для добавления обработчиков событий. `addEventListener(eventType, listener, useCapture)` - добавляет обработчик события. `removeEventListener(eventType, listener, useCapture)` - удаляет обработчик события. `eventType` - тип события (например, 'click', 'mouseover'). `listener` - функция, которая будет вызвана при возникновении события. `useCapture` - определяет, будет ли обработчик перехватывать событие на этапе захвата (true) или всплытия (false).  Регистрация обработчиков событий позволяет реагировать на действия пользователя (клики, наведение мыши, нажатие клавиш и т.д.) и динамически изменять поведение веб-страницы.",
          "Node Properties": "Различные свойства DOM узлов: parentNode, childNodes, firstChild, lastChild, nextSibling, previousSibling, innerHTML, textContent"
      },
      "Events": {
        "Event Listeners": "Регистрация обработчиков событий с помощью `addEventListener()`. Позволяет добавить несколько обработчиков на один и тот же элемент и событие. Можно также регистрировать обработчики событий на этапе захвата или всплытия.",
        "Event Types": "Типы событий. `click` - клик мышью. `mouseover` - наведение мыши. `mouseout` - отведение мыши. `keydown` - нажатие клавиши. `keyup` - отпускание клавиши. `submit` - отправка формы. `load` - загрузка ресурса (например, изображения, страницы). `DOMContentLoaded` - DOM-дерево построено. `scroll` - прокрутка элемента.",
        "Event Object": "Объект, передаваемый в обработчик события. Содержит информацию о событии (например, координаты мыши, нажатую клавишу, целевой элемент). `event.target` - целевой элемент, на котором произошло событие. `event.type` - тип события. `event.clientX`, `event.clientY` - координаты мыши. `event.key` - нажатая клавиша.",
        "Event Propagation (Bubbling and Capturing)": "Порядок, в котором события распространяются по DOM-дереву. Всплытие (bubbling) - от целевого элемента к корню. Перехват (capturing) - от корня к целевому элементу. По умолчанию события распространяются на этапе всплытия.",
        "preventDefault()": "Метод, отменяющий действие события по умолчанию. Например, отменяет отправку формы при нажатии кнопки submit или переход по ссылке.",
        "stopPropagation()": "Метод, останавливающий распространение события по DOM-дереву. Предотвращает вызов обработчиков событий на родительских элементах."
      },
      "Asynchronous JavaScript": {
        "async/await": "Синтаксический сахар над промисами (ES8). Позволяет писать асинхронный код, как синхронный. `async` - указывает, что функция является асинхронной. `await` - приостанавливает выполнение функции до разрешения промиса. `async/await` делает асинхронный код более читаемым и понятным.",
        "setTimeout(), setInterval()": "Функции для выполнения кода с задержкой. `setTimeout(callback, delay)` - выполняет код один раз через указанное время (в миллисекундах). `setInterval(callback, delay)` - выполняет код периодически через указанное время (в миллисекундах). Используйте `clearInterval()` для остановки `setInterval()`.",
        "RequestAnimationFrame()": "Функция для выполнения кода перед следующим перерисовыванием браузера. Используется для создания анимаций и оптимизации производительности."
      },
       "Error Handling": {
          "try...catch": "Блок для обработки исключений. Код, который может вызвать ошибку, помещается в блок `try`, а код для обработки ошибки – в блок `catch`. Позволяет предотвратить аварийное завершение программы при возникновении ошибки.",
          "throw": "Оператор для генерации исключений. `throw new Error("My error message");`. Позволяет создать исключение и передать его в блок `catch`.",
          "finally": "Блок, который выполняется всегда, независимо от того, было ли исключение или нет. Используется для освобождения ресурсов (например, закрытия файлов, освобождения памяти). Блок `finally` выполняется после блока `try` и блока `catch` (если исключение было поймано).",
          "Error Object": "Объект ошибки, который передается в блок `catch`. Содержит информацию об ошибке, такую как сообщение об ошибке (message) и имя ошибки (name)."
       },
      "Modules": {
        "CommonJS (Node.js)": "Система модулей, используемая в Node.js. Модули экспортируются с помощью `module.exports` и импортируются с помощью `require()`. CommonJS - синхронная система модулей.",
        "ES Modules (ES6)": "Стандартизированная система модулей JavaScript. Модули экспортируются с помощью `export` и импортируются с помощью `import`. ES Modules - асинхронная система модулей.",
        "import, export": "Ключевые слова для импорта и экспорта модулей в ES модулях. `export default myVariable;` - экспорт по умолчанию. `export { myVariable1, myVariable2 };` - именованный экспорт. `import myVariable from './myModule.js';` - импорт по умолчанию. `import { myVariable1, myVariable2 } from './myModule.js';` - именованный импорт. `import * as myModule from './myModule.js';` - импорт всего модуля в объект.",
        "Dynamic Imports": "Позволяют загружать модули динамически (по требованию) с помощью функции `import()`. Возвращает Promise."
      },
      "JSON (JavaScript Object Notation)": {
        "Structure": "Текстовый формат обмена данными, основанный на JavaScript-объектах. Легко читаемый и простой в использовании. Широко используется для передачи данных между сервером и клиентом.",
        "stringify()": "Метод для преобразования JavaScript-объекта в JSON-строку. `JSON.stringify(myObject, replacer, space)`. `replacer` - функция или массив, которые используются для преобразования значений. `space` - количество пробелов для отступов.",
        "parse()": "Метод для преобразования JSON-строки в JavaScript-объект. `JSON.parse(myJSONString, reviver)`. `reviver` - функция, которая используется для преобразования значений.",
        "JSON.isValid()": "Метод для проверки, является ли строка допустимым JSON (ES2023)."
      },
      "Regular Expressions": {
        "Pattern Matching": "Шаблоны для поиска и замены текста. Позволяют выполнять сложные операции поиска и замены текста.",
        "RegExp Object": "Объект, представляющий регулярное выражение. `const myRegex = /pattern/flags;` (литеральная нотация) или `const myRegex = new RegExp("pattern", "flags");` (конструктор).",
        "Methods": "Методы для работы с регулярными выражениями. `test(string)` - проверяет, соответствует ли строка шаблону (возвращает true или false). `exec(string)` - выполняет поиск соответствия в строке и возвращает массив с информацией о соответствии (или null). `match(regex)` - выполняет поиск соответствий в строке и возвращает массив с результатами (или null). `replace(regex, replacement)` - заменяет соответствия в строке на указанную замену. `search(regex)` - ищет соответствие в строке и возвращает индекс первого соответствия (или -1). `split(regex)` - разбивает строку на массив подстрок, используя регулярное выражение в качестве разделителя.",
        "Flags": "Флаги, определяющие поведение регулярного выражения. `g` (глобальный поиск - находит все соответствия), `i` (игнорирование регистра), `m` (многострочный поиск), `s` (dotall - точка (.) соответствует любому символу, включая перенос строки), `u` (unicode - поддержка Unicode), `y` (sticky - поиск с определенной позиции).",
        "Character Classes": "[abc] (любой символ из a, b или c), [^abc] (любой символ, кроме a, b или c), [a-z] (любой символ из диапазона a-z), [0-9] (любая цифра), \\d (цифра), \\D (не цифра), \\w (буква, цифра или подчеркивание), \\W (не буква, не цифра и не подчеркивание), \\s (пробельный символ), \\S (не пробельный символ).",
        "Quantifiers": "* (0 или более раз), + (1 или более раз), ? (0 или 1 раз), {n} (ровно n раз), {n,} (n или более раз), {n,m} (от n до m раз).",
        "Anchors": "^ (начало строки), $ (конец строки), \\b (граница слова), \\B (не граница слова).",
        "Grouping and Capturing": "(...) (группировка), \\1, \\2, ... (обратные ссылки на группы)."
      },
      "Web APIs": {
        "Fetch API": "Интерфейс для отправки HTTP-запросов. Заменяет XMLHttpRequest. Основан на промисах, что упрощает работу с асинхронными запросами.",
        "Local Storage API": "Интерфейс для хранения данных в браузере локально. Данные сохраняются между сессиями. Ограниченный объем хранилища (обычно 5-10 МБ). Используется для хранения небольших объемов данных, таких как настройки пользователя или данные авторизации.",
        "Session Storage API": "Интерфейс для хранения данных в браузере на время текущей сессии. Данные удаляются при закрытии браузера. Используется для хранения временных данных, таких как данные корзины покупок.",
        "Geolocation API": "Интерфейс для получения географического положения пользователя. Требует разрешения пользователя.",
        "Canvas API": "Интерфейс для рисования графики на веб-странице. Позволяет создавать интерактивные графики, игры и визуализации.",
        "Web Workers API": "Интерфейс для запуска JavaScript в фоновом потоке. Позволяет выполнять длительные операции без блокировки пользовательского интерфейса. Используется для повышения производительности веб-приложений.",
        "WebSockets API": "Интерфейс для создания двунаправленных соединений между клиентом и сервером. Позволяет в режиме реального времени обмениваться данными между клиентом и сервером.",
        "Service Workers API": "Интерфейс для создания прокси-серверов на стороне клиента. Позволяет реализовать оффлайн-режим, push-уведомления и другие функции.",
        "Intersection Observer API": "Интерфейс для отслеживания видимости элементов на странице. Позволяет выполнять код, когда элемент становится видимым или невидимым.",
        "Mutation Observer API": "Интерфейс для отслеживания изменений в DOM-дереве."
      },
       "Modern JavaScript Features (ES6+)": {
          "Arrow Functions": "Компактный синтаксис для определения функций. `() => {}`. Не имеют собственного `this` и `arguments`.",
          "let and const": "Блочная область видимости переменных. Улучшают организацию кода и предотвращают случайное переопределение переменных.",
          "Template Literals": "Строки с возможностью встраивания выражений. ``Hello, ${name}!``. Упрощают создание сложных строк и многострочных строк.",
          "Destructuring Assignment": "Извлечение значений из объектов и массивов. `const { a, b } = obj; const [first, second] = array;`. Упрощает доступ к данным в объектах и массивах.",
          "Spread Operator (...)": "Расширение массивов и объектов. `const newArray = [...array1, ...array2]; const newObject = { ...object1, ...object2 };`. Упрощает объединение массивов и объектов.",
          "Classes": "Синтаксический сахар над прототипным наследованием. Упрощают создание объектов и управление наследованием.",
          "Promises": "Управление асинхронными операциями. Улучшают читаемость и поддержку асинхронного кода.",
          "Async/Await": "Упрощенный синтаксис для работы с асинхронным кодом. Позволяет писать асинхронный код, как синхронный.",
          "Modules": "Система модулей для организации кода. Улучшает организацию кода и предотвращает конфликты имен.",
          "Default Parameters": "Параметры функций со значениями по умолчанию. Упрощает написание функций с необязательными аргументами.",
          "Rest Parameters": "Функции с переменным числом аргументов. Упрощает создание функций, которые могут принимать любое количество аргументов.",
           "Optional Chaining (?.)": "Безопасный доступ к свойствам объектов, которые могут быть null или undefined. `obj?.property?.nestedProperty`.",
           "Nullish Coalescing Operator (??)": "Возвращает правый операнд, если левый операнд равен null или undefined. В противном случае возвращает левый операнд. `value ?? defaultValue`.",
            "Private Class Fields (#)": "Приватные свойства классов (недоступны извне класса).",
            "Top-level Await": "Использование await вне async функций (в модулях)."
       },
        "Debugging Techniques": {
          "console.log()": "Вывод информации в консоль разработчика. Самый простой и распространенный способ отладки.",
          "console.table()": "Вывод данных в виде таблицы в консоли разработчика. Удобно для просмотра массивов и объектов.",
          "console.group() and console.groupEnd()": "Группировка сообщений в консоли разработчика. Упрощает чтение и организацию выводимых сообщений.",
          "debugger Statement": "Точка останова в коде для отладки в браузере. Позволяет приостановить выполнение кода и просмотреть значения переменных.",
          "Browser Developer Tools": "Инструменты разработчика в браузере для отладки, просмотра DOM, сетевых запросов и т.д. Предоставляют широкий набор инструментов для отладки и анализа веб-приложений.",
          "Error Messages": "Анализ сообщений об ошибках в консоли для выявления проблем. Сообщения об ошибках часто содержат информацию о причине ошибки и месте ее возникновения.",
          "Linting (ESLint)": "Использование линтеров для выявления синтаксических ошибок и стилистических проблем. Линтеры помогают поддерживать единый стиль кодирования и предотвращают распространенные ошибки.",
          "Source Maps": "Использование source maps для отладки минифицированного кода. Source maps позволяют связать минифицированный код с исходным кодом, что упрощает отладку."
      },
       "Best Practices": {
           "Code Readability": "Использование понятных имен переменных и функций, отступов и комментариев для улучшения читаемости кода. Читаемый код проще понимать, отлаживать и поддерживать.",
           "Code Modularity": "Разделение кода на небольшие, независимые модули для повторного использования и упрощения поддержки. Модульный код проще тестировать и изменять.",
           "Error Handling": "Обработка ошибок для предотвращения сбоев приложения. Предотвращение необработанных исключений и предоставление информативных сообщений об ошибках пользователям.",
           "Performance Optimization": "Оптимизация кода для повышения производительности и скорости работы приложения. Использование эффективных алгоритмов, кэширование данных и оптимизация DOM-манипуляций.",
           "Security": "Предотвращение уязвимостей в коде для защиты от атак. Предотвращение XSS-атак, SQL-инъекций и других уязвимостей.",
           "Use Strict Mode": "Использование 'use strict'; в начале файла или функции для включения строгого режима. Строгий режим помогает выявлять ошибки и предотвращает использование устаревших возможностей JavaScript.",
           "Avoid Global Variables": "Избегание использования глобальных переменных для предотвращения конфликтов имен и повышения модульности кода.",
            "Write Unit Tests": "Написание юнит-тестов для проверки правильности работы кода. Юнит-тесты помогают выявлять ошибки на ранних этапах разработки."
       },
       "JavaScript Frameworks and Libraries": {
            "React": "Библиотека JavaScript для создания пользовательских интерфейсов. Основана на компонентном подходе и виртуальном DOM.",
            "Angular": "Платформа JavaScript для создания веб-приложений. Предоставляет полный набор инструментов для разработки.",
            "Vue.js": "Прогрессивный фреймворк JavaScript для создания пользовательских интерфейсов. Легкий и простой в изучении.",
            "Node.js": "Среда выполнения JavaScript на стороне сервера. Позволяет использовать JavaScript для разработки серверных приложений.",
            "Express.js": "Веб-фреймворк для Node.js. Упрощает создание веб-приложений и API.",
            "jQuery": "Библиотека JavaScript, упрощающая DOM-манипуляции, анимации и AJAX-запросы (устаревает, рекомендуется использовать современные альтернативы).",
            "Lodash": "Библиотека JavaScript, предоставляющая множество полезных функций для работы с массивами, объектами и строками.",
            "Moment.js": "Библиотека JavaScript для работы с датами и временем (устаревает, рекомендуется использовать современные альтернативы, такие как Day.js или Luxon)."
       },
       "JavaScript Design Patterns": {
            "Module Pattern": "Организация кода в модули для инкапсуляции и сокрытия данных.",
            "Revealing Module Pattern": "Вариация Module Pattern, в которой явно указываются, какие свойства и методы модуля должны быть доступны извне.",
            "Singleton Pattern": "Создание только одного экземпляра класса.",
            "Observer Pattern": "Определение зависимости "один-ко-многим" между объектами, чтобы при изменении состояния одного объекта все зависимые объекты автоматически уведомлялись и обновлялись.",
            "Factory Pattern": "Создание объектов без указания конкретного класса.",
            "Prototype Pattern": "Создание новых объектов путем копирования существующего объекта (прототипа)."
       },
       "Progressive Web Apps (PWAs)": {
          "Service Workers": "Фоновые скрипты, которые позволяют реализовывать оффлайн-режим, push-уведомления и другие функции.",
          "Manifest File": "JSON-файл, описывающий приложение (имя, иконки, стартовый URL и т.д.).",
          "HTTPS": "Обязательное требование для PWAs.",
          "Benefits": "Оффлайн-режим, установка на рабочий стол, push-уведомления, высокая производительность."
       },
        "JavaScript Engines": {
            "V8 (Chrome, Node.js)": "Высокопроизводительный движок JavaScript, разработанный Google.",
            "SpiderMonkey (Firefox)": "Движок JavaScript, разработанный Mozilla.",
            "JavaScriptCore (Safari)": "Движок JavaScript, разработанный Apple."
        },
         "Internationalization (i18n) and Localization (l10n)": {
             "Intl API": "Встроенный API для форматирования чисел, дат и времени, а также для сравнения строк с учетом локали.",
             "Localization Libraries": "Библиотеки, такие как i18next, для управления переводами и локализацией веб-приложений."
         }
    }
  }