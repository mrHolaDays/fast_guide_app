{
  "Python Built-in Functions": {
    "Built-in Functions": {
      "abs()": "Возвращает абсолютное значение числа.",
      "all()": "Возвращает True, если все элементы итерируемого объекта истинны, иначе False.",
      "any()": "Возвращает True, если хотя бы один элемент итерируемого объекта истинен, иначе False.",
      "ascii()": "Возвращает представление объекта в виде строки, содержащей только ASCII символы.",
      "bin()": "Преобразует целое число в двоичную строку.",
      "bool()": "Преобразует значение в логический тип (True или False).",
      "bytearray()": "Создает изменяемый массив байтов.",
      "bytes()": "Создает неизменяемый массив байтов.",
      "callable()": "Возвращает True, если объект вызываемый (функция, метод, класс), иначе False.",
      "chr()": "Возвращает символ, соответствующий коду Unicode.",
      "classmethod()": "Преобразует метод в метод класса.",
      "compile()": "Компилирует исходный код в объект кода.",
      "complex()": "Создает комплексное число.",
      "delattr()": "Удаляет атрибут объекта.",
      "dict()": "Создает словарь.",
      "dir()": "Возвращает список атрибутов и методов объекта.",
      "divmod()": "Возвращает кортеж, содержащий частное и остаток от деления.",
      "enumerate()": "Возвращает объект перечислителя.",
      "eval()": "Вычисляет выражение Python.",
      "exec()": "Выполняет код Python.",
      "filter()": "Фильтрует элементы итерируемого объекта на основе функции.",
      "float()": "Преобразует значение в число с плавающей точкой.",
      "format()": "Форматирует значение.",
      "frozenset()": "Создает неизменяемое множество.",
      "getattr()": "Возвращает значение атрибута объекта.",
      "globals()": "Возвращает словарь текущего глобального пространства имен.",
      "hasattr()": "Возвращает True, если объект имеет указанный атрибут, иначе False.",
      "hash()": "Возвращает хеш-значение объекта.",
      "help()": "Вызывает встроенную систему помощи.",
      "hex()": "Преобразует целое число в шестнадцатеричную строку.",
      "id()": "Возвращает уникальный идентификатор объекта.",
      "input()": "Считывает строку с консоли.",
      "int()": "Преобразует значение в целое число.",
      "isinstance()": "Возвращает True, если объект является экземпляром класса или его подкласса, иначе False.",
      "issubclass()": "Возвращает True, если класс является подклассом другого класса, иначе False.",
      "iter()": "Возвращает итератор для объекта.",
      "len()": "Возвращает длину объекта.",
      "list()": "Создает список.",
      "locals()": "Возвращает словарь текущего локального пространства имен.",
      "map()": "Применяет функцию к каждому элементу итерируемого объекта.",
      "max()": "Возвращает максимальный элемент итерируемого объекта.",
      "memoryview()": "Создает объект memoryview.",
      "min()": "Возвращает минимальный элемент итерируемого объекта.",
      "next()": "Возвращает следующий элемент итератора.",
      "object()": "Создает базовый объект.",
      "oct()": "Преобразует целое число в восьмеричную строку.",
      "open()": "Открывает файл.",
      "ord()": "Возвращает кодовое значение символа Unicode.",
      "pow()": "Возводит число в степень.",
      "print()": "Выводит значение в консоль.",
      "property()": "Создает свойство.",
      "range()": "Создает последовательность чисел.",
      "repr()": "Возвращает строковое представление объекта.",
      "reversed()": "Возвращает итератор, который перебирает элементы итерируемого объекта в обратном порядке.",
      "round()": "Округляет число до указанной точности.",
      "set()": "Создает множество.",
      "setattr()": "Устанавливает значение атрибута объекта.",
      "slice()": "Создает объект среза.",
      "sorted()": "Сортирует элементы итерируемого объекта.",
      "staticmethod()": "Преобразует метод в статический метод.",
      "str()": "Преобразует значение в строку.",
      "sum()": "Возвращает сумму элементов итерируемого объекта.",
      "super()": "Вызывает метод родительского класса.",
      "tuple()": "Создает кортеж.",
      "type()": "Возвращает тип объекта.",
      "vars()": "Возвращает словарь атрибутов объекта.",
      "zip()": "Объединяет элементы из нескольких итерируемых объектов.",
      "__import__()": "Импортирует модуль.",
      "breakpoint()": "Вызывает отладчик (PEP 553)"
    },
    "String Methods": {
      "capitalize()": "Преобразует первый символ строки в верхний регистр, остальные - в нижний.",
      "casefold()": "Преобразует строку в нижний регистр для безразличного сравнения (более агрессивный, чем lower()).",
      "center()": "Выравнивает строку по центру в строке заданной ширины.",
      "count()": "Возвращает количество вхождений подстроки.",
      "encode()": "Кодирует строку.",
      "endswith()": "Возвращает True, если строка заканчивается указанной подстрокой.",
      "expandtabs()": "Заменяет символы табуляции на пробелы.",
      "find()": "Ищет первую позицию подстроки.",
      "format()": "Форматирует строку.",
      "format_map()": "Форматирует строку с использованием словаря.",
      "index()": "Ищет первую позицию подстроки (вызывает исключение, если не найдено).",
      "isalnum()": "Возвращает True, если все символы строки являются буквенно-цифровыми.",
      "isalpha()": "Возвращает True, если все символы строки являются буквами.",
      "isascii()": "Возвращает True, если все символы строки ASCII.",
      "isdecimal()": "Возвращает True, если все символы строки являются десятичными цифрами.",
      "isdigit()": "Возвращает True, если все символы строки являются цифрами.",
      "isidentifier()": "Возвращает True, если строка является допустимым идентификатором.",
      "islower()": "Возвращает True, если все символы строки в нижнем регистре.",
      "isnumeric()": "Возвращает True, если все символы строки являются числовыми.",
      "isprintable()": "Возвращает True, если все символы строки являются печатными.",
      "isspace()": "Возвращает True, если все символы строки являются пробельными.",
      "istitle()": "Возвращает True, если строка является заголовком (первая буква каждого слова в верхнем регистре).",
      "isupper()": "Возвращает True, если все символы строки в верхнем регистре.",
      "join()": "Объединяет элементы итерируемого объекта в строку.",
      "ljust()": "Выравнивает строку по левому краю в строке заданной ширины.",
      "lower()": "Преобразует строку в нижний регистр.",
      "lstrip()": "Удаляет начальные пробельные символы.",
      "maketrans()": "Создает таблицу перевода для str.translate().",
      "partition()": "Разделяет строку на три части вокруг первого вхождения разделителя.",
      "removeprefix()": "Удаляет указанный префикс из строки (Python 3.9+).",
      "removesuffix()": "Удаляет указанный суффикс из строки (Python 3.9+).",
      "replace()": "Заменяет подстроку другой подстрокой.",
      "rfind()": "Ищет последнюю позицию подстроки.",
      "rindex()": "Ищет последнюю позицию подстроки (вызывает исключение, если не найдено).",
      "rjust()": "Выравнивает строку по правому краю в строке заданной ширины.",
      "rpartition()": "Разделяет строку на три части вокруг последнего вхождения разделителя.",
      "rsplit()": "Разделяет строку на список строк, начиная с конца.",
      "rstrip()": "Удаляет конечные пробельные символы.",
      "split()": "Разделяет строку на список строк.",
      "splitlines()": "Разделяет строку на список строк по символам новой строки.",
      "startswith()": "Возвращает True, если строка начинается с указанной подстроки.",
      "strip()": "Удаляет начальные и конечные пробельные символы.",
      "swapcase()": "Меняет регистр символов в строке.",
      "title()": "Преобразует строку в заголовок (первая буква каждого слова в верхнем регистре).",
      "translate()": "Заменяет символы в строке с использованием таблицы перевода.",
      "upper()": "Преобразует строку в верхний регистр.",
      "zfill()": "Дополняет строку нулями слева до заданной ширины."
    },
    "List Methods": {
      "append()": "Добавляет элемент в конец списка.",
      "clear()": "Удаляет все элементы из списка.",
      "copy()": "Возвращает поверхностную копию списка.",
      "count()": "Возвращает количество вхождений элемента в список.",
      "extend()": "Добавляет элементы из другого итерируемого объекта в конец списка.",
      "index()": "Возвращает индекс первого вхождения элемента в список.",
      "insert()": "Вставляет элемент в список по указанному индексу.",
      "pop()": "Удаляет и возвращает элемент из списка по указанному индексу (по умолчанию последний).",
      "remove()": "Удаляет первое вхождение элемента из списка.",
      "reverse()": "Меняет порядок элементов в списке на обратный.",
      "sort()": "Сортирует элементы списка (по умолчанию по возрастанию)."
    },
    "Dictionary Methods": {
      "clear()": "Удаляет все элементы из словаря.",
      "copy()": "Возвращает поверхностную копию словаря.",
      "fromkeys()": "Создает новый словарь с ключами из итерируемого объекта и значениями, равными указанному значению (или None по умолчанию).",
      "get()": "Возвращает значение для указанного ключа. Если ключ не найден, возвращает указанное значение (или None по умолчанию).",
      "items()": "Возвращает представление ключей и значений словаря.",
      "keys()": "Возвращает представление ключей словаря.",
      "pop()": "Удаляет и возвращает значение для указанного ключа.",
      "popitem()": "Удаляет и возвращает пару (ключ, значение) из словаря (в порядке LIFO).",
      "setdefault()": "Возвращает значение для указанного ключа. Если ключ не найден, вставляет ключ со значением (по умолчанию None) и возвращает его.",
      "update()": "Обновляет словарь элементами из другого словаря или итерируемого объекта пар ключ-значение.",
      "values()": "Возвращает представление значений словаря."
    },
    "Set Methods": {
      "add()": "Добавляет элемент в множество.",
      "clear()": "Удаляет все элементы из множества.",
      "copy()": "Возвращает поверхностную копию множества.",
      "difference()": "Возвращает множество, содержащее элементы, которые есть в первом множестве, но отсутствуют в других.",
      "difference_update()": "Удаляет элементы, которые есть в других множествах, из первого множества.",
      "discard()": "Удаляет элемент из множества.  Если элемента нет, не вызывает исключения.",
      "intersection()": "Возвращает множество, содержащее элементы, которые есть во всех множествах.",
      "intersection_update()": "Сохраняет только элементы, которые есть во всех множествах, в первом множестве.",
      "isdisjoint()": "Возвращает True, если множества не имеют общих элементов.",
      "issubset()": "Возвращает True, если множество является подмножеством другого множества.",
      "issuperset()": "Возвращает True, если множество является надмножеством другого множества.",
      "pop()": "Удаляет и возвращает произвольный элемент из множества.  Вызывает исключение, если множество пустое.",
      "remove()": "Удаляет элемент из множества.  Вызывает исключение, если элемента нет.",
      "symmetric_difference()": "Возвращает множество, содержащее элементы, которые есть только в одном из множеств.",
      "symmetric_difference_update()": "Оставляет только элементы, которые есть только в одном из множеств, в первом множестве.",
      "union()": "Возвращает множество, содержащее элементы из всех множеств.",
      "update()": "Добавляет элементы из другого итерируемого объекта в множество."
    },
     "File Object Methods": {
      "read()": "Считывает данные из файла.",
      "readline()": "Считывает одну строку из файла.",
      "readlines()": "Считывает все строки из файла в список.",
      "write()": "Записывает данные в файл.",
      "writelines()": "Записывает список строк в файл.",
      "close()": "Закрывает файл.",
      "flush()": "Сбрасывает буферизованные данные в файл.",
      "fileno()": "Возвращает файловый дескриптор.",
      "isatty()": "Возвращает True, если файл подключен к терминалу.",
      "readable()": "Возвращает True, если файл доступен для чтения.",
      "readline()": "Считывает одну строку из файла.",
      "seek()": "Перемещает позицию чтения/записи в файле.",
      "seekable()": "Возвращает True, если seek() поддерживается.",
      "tell()": "Возвращает текущую позицию чтения/записи в файле.",
      "truncate()": "Усекает файл до указанного размера.",
      "writable()": "Возвращает True, если файл доступен для записи.",
      "writelines()": "Записывает список строк в файл."
    },
  
  
    "Python Functions": {
      "builtins": {
        "print()": "Выводит данные на стандартный вывод (обычно консоль).  Принимает несколько аргументов, которые разделяются пробелами.",
        "len()": "Возвращает длину объекта (строки, списка, кортежа, словаря, множества и т.д.).  Длина - это количество элементов, содержащихся в объекте.",
        "type()": "Возвращает тип объекта.  Используется для определения класса объекта.",
        "int()": "Преобразует значение в целое число.  Можно указать основание системы счисления для преобразования строк.",
        "float()": "Преобразует значение в число с плавающей точкой.",
        "str()": "Преобразует значение в строку.  Любой объект может быть представлен в виде строки.",
        "list()": "Создает список.  Можно создать пустой список или преобразовать другой итерируемый объект в список.",
        "tuple()": "Создает кортеж.  Кортежи неизменяемы.",
        "dict()": "Создает словарь.  Словари хранят пары ключ-значение.",
        "set()": "Создает множество.  Множества содержат только уникальные элементы.",
        "range()": "Создает последовательность чисел.  Часто используется в циклах `for`.",
        "sum()": "Суммирует элементы итерируемого объекта (списка, кортежа и т.д.).",
        "max()": "Возвращает максимальный элемент итерируемого объекта.",
        "min()": "Возвращает минимальный элемент итерируемого объекта.",
        "abs()": "Возвращает абсолютное значение числа (модуль числа).",
        "round()": "Округляет число до указанного количества знаков после запятой.",
        "pow()": "Возводит число в степень.  Эквивалентно оператору `**`.",
        "input()": "Считывает данные со стандартного ввода (обычно с клавиатуры).  Возвращает строку.",
        "open()": "Открывает файл.  Позволяет читать и записывать данные в файл.",
        "enumerate()": "Возвращает итератор, который выдает пары (индекс, элемент) для каждого элемента в итерируемом объекте.",
        "zip()": "Объединяет несколько итерируемых объектов в один итератор, выдающий кортежи элементов из каждого объекта.",
        "filter()": "Фильтрует элементы итерируемого объекта на основе заданной функции.",
        "map()": "Применяет функцию к каждому элементу итерируемого объекта и возвращает итератор с результатами.",
        "sorted()": "Возвращает новый отсортированный список из элементов итерируемого объекта."
      },
      "string": {
        "ascii_letters": "Содержит все ASCII буквы (верхний и нижний регистр): 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.",
        "ascii_lowercase": "Содержит все ASCII буквы в нижнем регистре: 'abcdefghijklmnopqrstuvwxyz'.",
        "ascii_uppercase": "Содержит все ASCII буквы в верхнем регистре: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.",
        "digits": "Содержит все цифры (0-9): '0123456789'.",
        "hexdigits": "Содержит все шестнадцатеричные цифры: '0123456789abcdefABCDEF'.",
        "octdigits": "Содержит все восьмеричные цифры: '01234567'.",
        "punctuation": "Содержит все знаки пунктуации.",
        "whitespace": "Содержит все символы пробелов: ' \\t\\n\\r\\x0b\\x0c'.",
        "capwords()": "Преобразует строку, делая первую букву каждого слова заглавной."
      },
      "re": {
        "search()": "Ищет первое соответствие шаблону в строке.  Возвращает объект Match, если соответствие найдено, и None, если нет.",
        "match()": "Пытается сопоставить шаблон с начала строки.  Возвращает объект Match, если соответствие найдено, и None, если нет.",
        "findall()": "Находит все неперекрывающиеся соответствия шаблону в строке и возвращает их в виде списка строк.",
        "finditer()": "Находит все соответствия шаблону в строке и возвращает итератор объектов Match.",
        "sub()": "Заменяет все соответствия шаблону в строке на заданную строку или результат вызова функции.",
        "split()": "Разбивает строку на подстроки по заданному шаблону.  Возвращает список строк.",
        "compile()": "Компилирует регулярное выражение в объект регулярного выражения.  Компиляция улучшает производительность при многократном использовании шаблона.",
        "escape()": "Экранирует специальные символы в строке, чтобы их можно было использовать в регулярном выражении.",
        "Pattern": {
          "match()": "Сопоставляет шаблон с начала строки (метод объекта Pattern).",
          "search()": "Ищет соответствие шаблону в строке (метод объекта Pattern).",
          "findall()": "Находит все соответствия шаблону в строке (метод объекта Pattern).",
          "finditer()": "Находит все соответствия шаблону в строке и возвращает итератор (метод объекта Pattern).",
          "sub()": "Заменяет соответствия шаблону в строке (метод объекта Pattern).",
          "split()": "Разбивает строку на подстроки по шаблону (метод объекта Pattern)."
        },
        "Match": {
          "group()": "Возвращает подстроку, соответствующую группе (метод объекта Match).",
          "groups()": "Возвращает кортеж всех подстрок, соответствующих группам (метод объекта Match).",
          "start()": "Возвращает начальную позицию соответствия (метод объекта Match).",
          "end()": "Возвращает конечную позицию соответствия (метод объекта Match).",
          "span()": "Возвращает кортеж (start, end) с начальной и конечной позициями соответствия (метод объекта Match)."
        }
      },
      "struct": {
        "pack()": "Упаковывает значения данных в строку байтов в соответствии с заданным форматом.  Формат определяет типы данных и их порядок.",
        "unpack()": "Распаковывает строку байтов в значения данных в соответствии с заданным форматом.",
        "calcsize()": "Возвращает размер структуры в байтах в соответствии с заданным форматом.",
        "pack_into()": "Упаковывает значения в буфер, начиная с заданного смещения.",
        "unpack_from()": "Распаковывает значения из буфера, начиная с заданного смещения."
      },
      "json": {
        "dumps()": "Преобразует объект Python в строку JSON.  Поддерживает различные параметры для форматирования вывода (отступы, сортировка ключей и т.д.).",
        "loads()": "Преобразует строку JSON в объект Python.",
        "dump()": "Записывает объект Python в файл JSON.",
        "load()": "Считывает объект Python из файла JSON.",
        "JSONEncoder": {
          "encode()": "Метод для кодирования объекта Python в строку JSON (метод класса JSONEncoder).",
          "default()": "Метод, вызываемый для объектов, которые не могут быть закодированы напрямую (метод класса JSONEncoder)."
        },
        "JSONDecoder": {
          "decode()": "Метод для декодирования строки JSON в объект Python (метод класса JSONDecoder).",
          "raw_decode()": "Декодирует строку JSON, возвращая объект и индекс, где закончилось декодирование (метод класса JSONDecoder)."
        }
      },
      "csv": {
        "reader()": "Создает объект-читатель для чтения CSV-файла.  Итерируется по строкам файла.",
        "writer()": "Создает объект-писатель для записи в CSV-файл.",
        "DictReader()": "Создает объект-читатель для чтения CSV-файла как словаря.  Первая строка файла используется как заголовки столбцов (ключи словаря).",
        "DictWriter()": "Создает объект-писатель для записи в CSV-файл как словарь.",
        "register_dialect()": "Регистрирует новый диалект CSV.",
        "get_dialect()": "Получает диалект CSV по имени.",
        "list_dialects()": "Возвращает список зарегистрированных диалектов CSV."
      },
      "xml": {
        "etree": {
          "fromstring()": "Преобразует строку XML в объект ElementTree.",
          "Element()": "Создает новый элемент XML.",
          "SubElement()": "Создает дочерний элемент XML.",
          "tostring()": "Преобразует объект ElementTree в строку XML.",
          "parse()": "Парсит XML файл и возвращает ElementTree.",
          "ElementTree": {
            "getroot()": "Возвращает корневой элемент дерева (метод ElementTree).",
            "write()": "Записывает ElementTree в файл (метод ElementTree).",
            "find()": "Находит первый элемент, соответствующий заданному пути (метод ElementTree).",
            "findall()": "Находит все элементы, соответствующие заданному пути (метод ElementTree)."
          },
          "Element": {
            "tag": "Атрибут, содержащий имя тега элемента.",
            "attrib": "Атрибут, содержащий словарь атрибутов элемента.",
            "text": "Атрибут, содержащий текст, содержащийся в элементе.",
            "get()": "Возвращает значение атрибута по имени (метод Element).",
            "set()": "Устанавливает значение атрибута (метод Element).",
            "append()": "Добавляет дочерний элемент (метод Element).",
            "remove()": "Удаляет дочерний элемент (метод Element).",
            "find()": "Находит первый дочерний элемент, соответствующий заданному пути (метод Element).",
            "findall()": "Находит все дочерние элементы, соответствующие заданному пути (метод Element)."
          }
        }
      },
      "io": {
        "StringIO()": "Работает со строками в памяти как с файлами.  Полезно для тестирования и обработки данных.",
        "BytesIO()": "Работает с байтами в памяти как с файлами.",
        "TextIOWrapper()": "Преобразует потоки байтов в текстовые потоки."
      },
      "os": {
        "getcwd()": "Возвращает текущий рабочий каталог.",
        "chdir()": "Изменяет текущий рабочий каталог.",
        "listdir()": "Возвращает список файлов и каталогов в указанном каталоге.",
        "mkdir()": "Создает каталог.",
        "makedirs()": "Создает каталоги рекурсивно.  Создает все необходимые промежуточные каталоги.",
        "rmdir()": "Удаляет каталог. Каталог должен быть пустым.",
        "removedirs()": "Удаляет каталоги рекурсивно.  Удаляет все пустые родительские каталоги.",
        "rename()": "Переименовывает файл или каталог.",
        "remove()": "Удаляет файл.",
        "stat()": "Возвращает информацию о файле или каталоге.  Содержит размер, время создания, изменения и т.д.",
        "path": {
          "abspath()": "Возвращает абсолютный путь.",
          "basename()": "Возвращает имя файла или каталога.",
          "dirname()": "Возвращает имя каталога.",
          "exists()": "Проверяет, существует ли файл или каталог.",
          "isfile()": "Проверяет, является ли файл файлом.",
          "isdir()": "Проверяет, является ли файл каталогом.",
          "join()": "Объединяет пути.  Обрабатывает разделители путей корректно для разных операционных систем.",
          "split()": "Разделяет путь на каталог и имя файла. Возвращает кортеж (каталог, имя файла).",
          "splitext()": "Разделяет имя файла на имя и расширение. Возвращает кортеж (имя, расширение).",
          "getsize()": "Возвращает размер файла в байтах.",
          "getmtime()": "Возвращает время последнего изменения файла в секундах с начала эпохи.",
          "getctime()": "Возвращает время создания файла в секундах с начала эпохи (зависит от ОС)."
  
        },
        "environ": "Словарь переменных окружения.  Содержит информацию о текущем окружении операционной системы.",
        "system()": "Выполняет системную команду.",
        "walk()": "Генерирует имена файлов в дереве каталогов, перемещаясь по дереву снизу вверх.  Возвращает кортеж (каталог, список подкаталогов, список файлов).",
        "sep": "Разделитель компонентов пути, специфичный для операционной системы (например, '/' в Linux и '\\\\' в Windows).",
        "pathsep": "Разделитель путей в переменной окружения PATH (например, ':' в Linux и ';' в Windows)."
      },
      "sys": {
        "argv": "Список аргументов командной строки.",
        "exit()": "Выход из программы.",
        "path": "Список путей поиска модулей.  Python ищет модули в этих каталогах.",
        "stdin": "Стандартный ввод (обычно клавиатура).",
        "stdout": "Стандартный вывод (обычно консоль).",
        "stderr": "Стандартный поток ошибок (обычно консоль).",
        "version": "Строка, содержащая версию Python.",
        "platform": "Строка, идентифицирующая операционную систему и аппаратную платформу.",
        "executable": "Абсолютный путь к исполняемому файлу Python.",
        "modules": "Словарь загруженных модулей."
      },
      "platform": {
        "system()": "Возвращает имя операционной системы (например, 'Windows', 'Linux', 'Darwin').",
        "release()": "Возвращает версию операционной системы.",
        "machine()": "Возвращает тип машины (например, 'x86_64', 'i386').",
        "processor()": "Возвращает имя процессора.",
        "version()": "Возвращает полную строку версии операционной системы."
      },
      "shutil": {
        "copy()": "Копирует файл.",
        "copytree()": "Копирует дерево каталогов.",
        "move()": "Перемещает файл или каталог.",
        "rmtree()": "Удаляет дерево каталогов.",
        "copy2()": "Копирует файл, сохраняя метаданные (время доступа, время изменения и т.д.).",
        "copystat()": "Копирует информацию о состоянии файла (метаданные).",
        "disk_usage()": "Возвращает информацию об использовании диска (общий объем, использованное пространство, свободное пространство)."
  
      },
      "glob": {
        "glob()": "Находит все пути, соответствующие заданному шаблону.  Поддерживает символы подстановки '*' и '?'.",
        "iglob()": "Возвращает итератор, который выдает пути, соответствующие шаблону."
      },
      "tempfile": {
        "TemporaryFile()": "Создает временный файл.  Файл удаляется автоматически при закрытии.",
        "TemporaryDirectory()": "Создает временный каталог. Каталог удаляется автоматически при выходе из контекста или при вызове close().",
        "mkstemp()": "Создает временный файл с уникальным именем.",
        "mkdtemp()": "Создает временный каталог с уникальным именем."
      },
      "math": {
        "pi": "Число пи (π).",
        "e": "Число Эйлера (e).",
        "sqrt()": "Возвращает квадратный корень числа.",
        "pow()": "Возводит число в степень.",
        "sin()": "Возвращает синус угла в радианах.",
        "cos()": "Возвращает косинус угла в радианах.",
        "tan()": "Возвращает тангенс угла в радианах.",
        "log()": "Возвращает логарифм числа.  Можно указать основание логарифма.",
        "log10()": "Возвращает десятичный логарифм числа.",
        "exp()": "Возвращает экспоненту числа (e в степени числа).",
        "ceil()": "Округляет число вверх до ближайшего целого.",
        "floor()": "Округляет число вниз до ближайшего целого.",
        "factorial()": "Возвращает факториал числа."
      },
      "cmath": {
        "sqrt()": "Возвращает квадратный корень комплексного числа.",
        "phase()": "Возвращает фазу комплексного числа.",
        "polar()": "Преобразует комплексное число в полярные координаты (радиус, угол).",
        "rect()": "Преобразует полярные координаты (радиус, угол) в комплексное число.",
        "sin()": "Возвращает синус комплексного числа.",
        "cos()": "Возвращает косинус комплексного числа.",
        "exp()": "Возвращает экспоненту комплексного числа."
      },
      "random": {
        "random()": "Возвращает случайное число с плавающей точкой в диапазоне [0.0, 1.0).",
        "randint()": "Возвращает случайное целое число в заданном диапазоне (включая границы).",
        "choice()": "Возвращает случайный элемент из последовательности.",
        "shuffle()": "Перемешивает элементы последовательности.",
        "uniform()": "Возвращает случайное число с плавающей точкой в заданном диапазоне.",
        "gauss()": "Возвращает случайное число из гауссовского распределения.",
        "seed()": "Инициализирует генератор случайных чисел."
      },
      "statistics": {
        "mean()": "Вычисляет среднее арифметическое списка чисел.",
        "median()": "Вычисляет медиану списка чисел.",
        "mode()": "Вычисляет моду списка чисел.",
        "stdev()": "Вычисляет стандартное отклонение списка чисел.",
        "variance()": "Вычисляет дисперсию списка чисел.",
        "pstdev()": "Вычисляет стандартное отклонение для генеральной совокупности.",
        "pvariance()": "Вычисляет дисперсию для генеральной совокупности."
      },
      "decimal": {
        "Decimal()": "Создает объект Decimal для точных вычислений с плавающей точкой.  Избегает проблем, связанных с представлением чисел с плавающей точкой в двоичной системе.",
        "getcontext()": "Возвращает текущий контекст Decimal.",
        "setcontext()": "Устанавливает текущий контекст Decimal.",
        "Context": {
          "prec": "Атрибут, определяющий точность вычислений.",
          "rounding": "Атрибут, определяющий режим округления.",
          "Emin": "Минимальное значение экспоненты.",
          "Emax": "Максимальное значение экспоненты."
        }
      },
      "fractions": {
        "Fraction()": "Создает объект Fraction для представления рациональных чисел.  Хранит число как отношение двух целых чисел (числитель и знаменатель).",
        "numerator": "Атрибут, содержащий числитель дроби.",
        "denominator": "Атрибут, содержащий знаменатель дроби."
      },
      "datetime": {
        "datetime": {
          "now()": "Возвращает текущую дату и время.",
          "strptime()": "Преобразует строку в объект datetime.",
          "strftime()": "Преобразует объект datetime в строку.  Позволяет форматировать дату и время в соответствии с заданным шаблоном.",
          "today()": "Возвращает текущую дату.",
          "utcnow()": "Возвращает текущую дату и время в UTC.",
          "combine()": "Объединяет дату и время в один объект datetime."
        },
        "date": {
          "today()": "Возвращает текущую дату.",
          "fromtimestamp()": "Создает объект date из временной метки (timestamp).",
          "year": "Атрибут, содержащий год.",
          "month": "Атрибут, содержащий месяц.",
          "day": "Атрибут, содержащий день."
        },
        "time": {
          "hour": "Атрибут, содержащий час.",
          "minute": "Атрибут, содержащий минуту.",
          "second": "Атрибут, содержащий секунду.",
          "microsecond": "Атрибут, содержащий микросекунду."
  
        },
        "timedelta": "Представляет разницу между двумя датами или временами.",
        "timezone": "Представляет информацию о часовом поясе."
      },
      "time": {
        "time()": "Возвращает текущее время в секундах с начала эпохи (Unix timestamp).",
        "sleep()": "Приостанавливает выполнение программы на заданное количество секунд.",
        "strftime()": "Преобразует объект времени в строку.",
        "strptime()": "Преобразует строку в объект времени.",
        "localtime()": "Преобразует время в локальное время.",
        "gmtime()": "Преобразует время в UTC.",
        "mktime()": "Преобразует объект времени в Unix timestamp."
      },
      "calendar": {
        "calendar()": "Возвращает календарь для заданного года.",
        "month()": "Возвращает календарь для заданного месяца и года.",
        "weekday()": "Возвращает день недели для заданной даты (0 - понедельник, 6 - воскресенье).",
        "isleap()": "Проверяет, является ли год високосным."
      },
      "zoneinfo": {
        "ZoneInfo()": "Представляет информацию о часовом поясе. Позволяет получать смещение от UTC и правила перехода на летнее время.",
        "available_timezones()": "Возвращает список доступных часовых поясов."
      },
      "threading": {
        "Thread()": "Создает новый поток.  Потоки позволяют выполнять код параллельно.",
        "Lock()": "Создает блокировку.  Блокировки используются для синхронизации доступа к общим ресурсам между потоками.",
        "RLock()": "Создает рекурсивную блокировку.  Рекурсивные блокировки позволяют одному и тому же потоку захватывать блокировку несколько раз.",
        "Condition()": "Создает условную переменную.  Условные переменные используются для уведомления потоков об изменении состояния.",
        "Semaphore()": "Создает семафор.  Семафоры ограничивают количество потоков, которые могут одновременно получить доступ к ресурсу.",
        "Event()": "Создает событие.  События используются для уведомления потоков о наступлении определенного события.",
        "current_thread()": "Возвращает объект, представляющий текущий поток.",
        "active_count()": "Возвращает количество активных потоков.",
        "enumerate()": "Возвращает список всех активных потоков."
      },
      "multiprocessing": {
        "Process()": "Создает новый процесс.  Процессы позволяют выполнять код параллельно в отдельных адресных пространствах.",
        "Pool()": "Создает пул процессов.  Пул процессов позволяет эффективно распределять задачи между несколькими процессами.",
        "Queue()": "Создает очередь для обмена данными между процессами.",
        "Pipe()": "Создает канал для обмена данными между процессами.",
        "Lock()": "Создает блокировку.  Используется для синхронизации доступа к общим ресурсам между процессами.",
        "Semaphore()": "Создает семафор. Используется для ограничения доступа к общему ресурсу.",
        "Value()": "Создает разделяемую переменную.",
        "Array()": "Создает разделяемый массив."
      },
      "asyncio": {
        "run()": "Запускает event loop.  Event loop управляет выполнением асинхронного кода.",
        "sleep()": "Корутина, приостанавливающая выполнение на заданное количество секунд.  Не блокирует event loop.",
        "create_task()": "Создает задачу (task) из корутины.  Задачи планируются для выполнения в event loop.",
        "gather()": "Запускает несколько корутин параллельно и ожидает их завершения.  Возвращает список результатов.",
        "get_event_loop()": "Возвращает текущий event loop.",
        "set_event_loop()": "Устанавливает текущий event loop.",
        "new_event_loop()": "Создает новый event loop.",
        "Task": {
          "cancel()": "Отменяет задачу.",
          "done()": "Проверяет, завершена ли задача.",
          "result()": "Возвращает результат задачи.",
          "exception()": "Возвращает исключение, возникшее при выполнении задачи."
        }
      },
      "concurrent": {
        "futures": {
          "ThreadPoolExecutor()": "Создает пул потоков для параллельного выполнения задач.",
          "ProcessPoolExecutor()": "Создает пул процессов для параллельного выполнения задач.",
          "Future": "Представляет результат асинхронной операции.",
          "as_completed()": "Возвращает итератор, который выдает Future по мере их завершения.",
          "wait()": "Ожидает завершения Future."
        }
      },
      "socket": {
        "socket()": "Создает сокет.",
        "bind()": "Привязывает сокет к адресу (IP-адрес и порт).",
        "listen()": "Начинает прослушивание входящих соединений.",
        "accept()": "Принимает входящее соединение.  Возвращает новый сокет и адрес клиента.",
        "connect()": "Устанавливает соединение с удаленным хостом.",
        "send()": "Отправляет данные через сокет.",
        "recv()": "Принимает данные через сокет.",
        "close()": "Закрывает сокет.",
        "AF_INET": "Семейство адресов IPv4.",
        "SOCK_STREAM": "Тип сокета TCP (потоковый).",
        "SOCK_DGRAM": "Тип сокета UDP (датаграммный).",
        "gethostname()": "Возвращает имя хоста.",
        "gethostbyname()": "Возвращает IP-адрес по имени хоста.",
        "getservbyname()": "Возвращает номер порта по имени сервиса."
      },
      "http": {
        "client": {
          "HTTPConnection()": "Создает HTTP-соединение.",
          "HTTPSConnection()": "Создает HTTPS-соединение.  Использует SSL/TLS для шифрования соединения.",
          "HTTPResponse": {
            "read()": "Читает тело ответа.",
            "getheader()": "Возвращает значение заголовка по имени.",
            "status": "Атрибут, содержащий код состояния HTTP (например, 200, 404, 500).",
            "reason": "Атрибут, содержащий текстовое описание кода состояния."
          }
        },
        "server": {
          "HTTPServer()": "Создает HTTP-сервер.",
          "BaseHTTPRequestHandler()": "Базовый класс для обработчиков HTTP-запросов.  Необходимо переопределить методы `do_GET()`, `do_POST()` и другие для обработки запросов.",
          "SimpleHTTPRequestHandler()": "Простой обработчик HTTP-запросов, который отдает файлы из текущего каталога."
        }
      },
      "urllib": {
        "request": {
          "urlopen()": "Открывает URL-адрес.",
          "Request()": "Создает HTTP-запрос.",
          "install_opener()": "Устанавливает объект OpenerDirector в качестве глобального обработчика URL.",
          "OpenerDirector": {
            "open()": "Открывает URL-адрес, используя установленные обработчики.",
            "add_handler()": "Добавляет обработчик URL."
          },
          "HTTPHandler": "Обработчик HTTP-запросов.",
          "ProxyHandler": "Обработчик HTTP-запросов через прокси-сервер."
        },
        "parse": {
          "urlparse()": "Разбирает URL-адрес на компоненты (схема, сетевое местоположение, путь, параметры, запрос, фрагмент).",
          "urlencode()": "Кодирует параметры URL-адреса.  Используется для создания строки запроса.",
          "quote()": "Кодирует отдельные символы в URL-адресе.",
          "unquote()": "Декодирует закодированные символы в URL-адресе."
        },
        "error": {
          "URLError": "Базовый класс для исключений, связанных с urllib.",
          "HTTPError": "Исключение, возникающее при получении HTTP-ответа с кодом ошибки (4xx или 5xx)."
        }
      },
      "email": {
        "message_from_string()": "Создает объект Message из строки.",
        "message_from_file()": "Создает объект Message из файла.",
        "Message": "Представляет электронное письмо.",
        "mime":{
          "multipart": {
            "MIMEMultipart": "Класс для создания составных сообщений (например, с вложениями)."
          },
          "text":{
            "MIMEText": "Класс для создания текстовых сообщений."
          },
          "base": {
            "MIMEBase": "Базовый класс для MIME-объектов."
          }
        }
  
      },
      "ssl": {
        "create_default_context()": "Создает контекст SSL по умолчанию.",
        "wrap_socket()": "Оборачивает сокет для использования SSL/TLS.  Добавляет шифрование к соединению.",
        "SSLContext": {
          "load_cert_chain()": "Загружает сертификат и приватный ключ.",
          "verify_mode": "Атрибут, определяющий режим проверки сертификата (например, CERT_REQUIRED, CERT_OPTIONAL, CERT_NONE)."
        },
        "CERT_NONE": "Режим проверки сертификата: не проверять сертификат.",
        "CERT_OPTIONAL": "Режим проверки сертификата: проверять, если сертификат предоставлен.",
        "CERT_REQUIRED": "Режим проверки сертификата: требовать предоставление сертификата и проверять его."
      },
      "sqlite3": {
        "connect()": "Устанавливает соединение с базой данных SQLite.",
        "Cursor": {
          "execute()": "Выполняет SQL-запрос.",
          "fetchall()": "Возвращает все результаты запроса в виде списка кортежей.",
          "fetchone()": "Возвращает следующий результат запроса в виде кортежа.",
          "executemany()": "Выполняет SQL-запрос несколько раз с разными параметрами."
        },
        "Connection": {
          "commit()": "Сохраняет изменения в базе данных.",
          "rollback()": "Отменяет изменения в базе данных.",
          "close()": "Закрывает соединение с базой данных.",
          "cursor()": "Создает объект Cursor."
        }
      },
      "tkinter": {
        "Tk()": "Создает главное окно приложения.",
        "Label()": "Создает текстовую метку.",
        "Button()": "Создает кнопку.",
        "Entry()": "Создает текстовое поле для ввода данных.",
        "Text()": "Создает многострочное текстовое поле.",
        "Canvas()": "Создает холст для рисования.",
        "mainloop()": "Запускает основной цикл обработки событий.",
        "Frame()": "Создает контейнер для других виджетов.",
        "Checkbutton()": "Создает флажок.",
        "Radiobutton()": "Создает переключатель.",
        "Listbox()": "Создает список.",
        "Scrollbar()": "Создает полосу прокрутки.",
        "Menu()": "Создает меню.",
        "messagebox": {
          "showinfo()": "Показывает информационное сообщение.",
          "showerror()": "Показывает сообщение об ошибке.",
          "askyesno()": "Запрашивает у пользователя подтверждение (да/нет)."
        }
      },
      "logging": {
        "getLogger()": "Возвращает объект Logger.",
        "basicConfig()": "Настраивает базовую конфигурацию журналирования.",
        "debug()": "Записывает отладочное сообщение.",
        "info()": "Записывает информационное сообщение.",
        "warning()": "Записывает предупреждающее сообщение.",
        "error()": "Записывает сообщение об ошибке.",
        "critical()": "Записывает критическое сообщение.",
        "Logger": {
          "setLevel()": "Устанавливает уровень журналирования.",
          "addHandler()": "Добавляет обработчик (Handler) для записи сообщений.",
          "removeHandler()": "Удаляет обработчик."
        },
        "Handler": {
          "setLevel()": "Устанавливает уровень журналирования для обработчика.",
          "setFormatter()": "Устанавливает форматтер (Formatter) для обработчика."
        },
        "Formatter": {
          "format()": "Форматирует сообщение."
        },
        "StreamHandler": "Обработчик, который записывает сообщения в поток (например, stderr).",
        "FileHandler": "Обработчик, который записывает сообщения в файл."
      },
      "unittest": {
      "TestCase": {
        "assertEqual()": "Проверяет равенство двух значений.",
        "assertTrue()": "Проверяет, что значение истинно.",
        "assertFalse()": "Проверяет, что значение ложно.",
        "assertRaises()": "Проверяет, что функция вызывает исключение.",
        "assertIsNone()": "Проверяет, что значение равно None.",
        "assertIsNotNone()": "Проверяет, что значение не равно None.",
        "assertIn()": "Проверяет, что элемент содержится в последовательности.",
        "assertNotIn()": "Проверяет, что элемент не содержится в последовательности.",
        "assertIsInstance()": "Проверяет, что объект является экземпляром класса.",
        "assertNotIsInstance()": "Проверяет, что объект не является экземпляром класса."
      },
      "main()": "Запускает тесты.",
      "TestSuite()": "Создает набор тестов.",
      "TextTestRunner()": "Запускает тесты и выводит результаты в текстовом формате."
    },
    "doctest": {
      "testmod()": "Запускает тесты, встроенные в модуль (в docstring).",
      "testfile()": "Запускает тесты из текстового файла.",
      "DocTestSuite()": "Создает набор тестов из docstring модуля или класса."
    },
    "pdb": {
      "set_trace()": "Вставляет точку останова в код.  При достижении этой точки выполнение программы приостанавливается и запускается интерактивный отладчик.",
      "pm()": "Запускает построчный отладчик после возникновения исключения.",
      "c": "Команда отладчика: continue (продолжить выполнение).",
      "n": "Команда отладчика: next (выполнить следующую строку).",
      "s": "Команда отладчика: step (войти в функцию).",
      "p": "Команда отладчика: print (вывести значение переменной).",
      "q": "Команда отладчика: quit (выйти из отладчика)."
    },
    "argparse": {
      "ArgumentParser()": "Создает парсер аргументов командной строки.",
      "add_argument()": "Добавляет аргумент.  Указывает имя, тип, действие и описание аргумента.",
      "parse_args()": "Разбирает аргументы командной строки.  Возвращает объект Namespace с атрибутами, соответствующими аргументам.",
      "Namespace": "Класс, используемый для хранения значений аргументов командной строки.",
      "ArgumentParser.add_mutually_exclusive_group()": "Создает группу взаимоисключающих аргументов."
    },
    "collections": {
      "Counter()": "Подсчитывает количество элементов в последовательности.  Возвращает словарь, где ключи - это элементы, а значения - количество их вхождений.",
      "defaultdict()": "Словарь, который автоматически создает значения по умолчанию для отсутствующих ключей.",
      "deque()": "Двусторонняя очередь.  Позволяет эффективно добавлять и удалять элементы с обоих концов.",
      "namedtuple()": "Создает именованный кортеж.  Позволяет обращаться к элементам кортежа по имени, а не только по индексу.",
      "OrderedDict()": "Словарь, который запоминает порядок добавления элементов."
    },
    "heapq": {
      "heappush()": "Добавляет элемент в кучу.",
      "heappop()": "Удаляет наименьший элемент из кучи.",
      "heapify()": "Преобразует список в кучу.",
      "heappushpop()": "Добавляет элемент в кучу, а затем удаляет наименьший элемент.",
      "heapreplace()": "Удаляет наименьший элемент из кучи и добавляет новый элемент."
    },
    "bisect": {
      "bisect_left()": "Находит индекс в отсортированном списке, куда можно вставить элемент, чтобы сохранить сортировку (слева).",
      "bisect_right()": "Находит индекс в отсортированном списке, куда можно вставить элемент, чтобы сохранить сортировку (справа).",
      "insort_left()": "Вставляет элемент в отсортированный список, сохраняя сортировку (слева).",
      "insort_right()": "Вставляет элемент в отсортированный список, сохраняя сортировку (справа)."
    },
    "enum": {
      "Enum()": "Создает перечисление.  Перечисления позволяют определить набор именованных констант.",
      "IntEnum()": "Создает перечисление, элементы которого являются целыми числами."
    },
    "typing": {
        "TYPE_CHECKING": "Константа, указывающая, выполняется ли проверка типов. Используется для условного импорта во время проверки типов.",
        "cast()": "Приводит значение к указанному типу (только для проверки типов). Не изменяет значение во время выполнения.",
        "NewType()": "Создает новый уникальный тип.  Полезно для различения типов, которые имеют одинаковое представление.",
        "TypeVar()": "Создает переменную типа.  Используется для определения обобщенных типов (generic types).",
        "Generic": "Базовый класс для создания обобщенных типов.",
        "List": "Тип для списка.",
        "Tuple": "Тип для кортежа.",
        "Dict": "Тип для словаря.",
        "Set": "Тип для множества.",
        "FrozenSet": "Тип для неизменяемого множества.",
        "Optional": "Тип для значения, которое может быть None.",
        "Union": "Тип для значения, которое может быть одним из нескольких типов.",
        "Callable": "Тип для вызываемого объекта (функции, метода).",
        "Any": "Тип, который может быть любым значением.",
        "NoReturn": "Тип, указывающий, что функция никогда не возвращает значение (например, всегда вызывает исключение).",
        "Literal": "Позволяет указать, что переменная может принимать только одно из заданных литеральных значений (начиная с Python 3.8)."
    },
    "copy": {
      "copy()": "Создает поверхностную копию объекта.  Новый объект содержит ссылки на те же объекты, что и исходный.",
      "deepcopy()": "Создает глубокую копию объекта.  Новый объект содержит копии всех объектов, на которые ссылается исходный объект."
    },
    "pprint": {
      "pprint()": "Выводит данные в удобном для чтения формате.",
      "pformat()": "Возвращает отформатированную строку представления объекта."
    },
    "reprlib": {
      "repr()": "Ограничивает длину представления объекта для отладки.",
      "recursive_repr()": "Декоратор для предотвращения бесконечной рекурсии при создании представления объекта."
    },
    "abc": {
      "ABCMeta": "Метакласс для создания абстрактных базовых классов.",
      "abstractmethod": "Декоратор для определения абстрактных методов.  Абстрактные методы должны быть реализованы в подклассах.",
      "abstractproperty": "Декоратор для определения абстрактных свойств."
    },
    "contextlib": {
      "contextmanager": "Декоратор для создания менеджеров контекста.  Позволяет определить код, который будет выполняться при входе и выходе из блока `with`.",
      "closing()": "Создает менеджер контекста, который автоматически закрывает объект при выходе из блока `with`.",
      "suppress()": "Создает менеджер контекста, который подавляет указанные исключения."
    },
    "itertools": {
      "count()": "Создает бесконечный итератор, генерирующий последовательные числа.",
      "cycle()": "Создает итератор, который повторяет элементы из заданного итерируемого объекта.",
      "repeat()": "Создает итератор, который повторяет заданный объект указанное количество раз.",
      "chain()": "Создает итератор, который объединяет несколько итерируемых объектов в один.",
      "combinations()": "Создает итератор, который генерирует все возможные комбинации элементов из заданного итерируемого объекта.",
      "permutations()": "Создает итератор, который генерирует все возможные перестановки элементов из заданного итерируемого объекта.",
      "product()": "Создает итератор, который генерирует все возможные декартовы произведения элементов из заданных итерируемых объектов.",
      "groupby()": "Группирует элементы итерируемого объекта по заданному ключу.  Возвращает итератор, выдающий пары (ключ, группа).",
      "islice()": "Создает итератор, который возвращает выбранные элементы из другого итератора."
    },
    "functools": {
      "partial()": "Создает новую функцию с некоторыми аргументами, уже заданными.",
      "lru_cache()": "Декоратор для кэширования результатов функции.  Улучшает производительность для функций, которые часто вызываются с одними и теми же аргументами.",
      "reduce()": "Применяет функцию к элементам итерируемого объекта, сводя их к одному значению.",
      "wraps()": "Декоратор для сохранения метаданных исходной функции при использовании декораторов."
    },
    "operator": {
      "add()": "Операция сложения.",
      "sub()": "Операция вычитания.",
      "mul()": "Операция умножения.",
      "truediv()": "Операция деления.",
      "floordiv()": "Операция целочисленного деления.",
      "mod()": "Операция взятия остатка от деления.",
      "pow()": "Операция возведения в степень.",
      "itemgetter()": "Функция для получения элементов из объекта по индексу или ключу.",
      "attrgetter()": "Функция для получения атрибутов объекта.",
      "methodcaller()": "Функция для вызова метода объекта."
    },
    "codecs": {
      "encode()": "Кодирует строку в байты.",
      "decode()": "Декодирует байты в строку.",
      "lookup()": "Ищет кодек по имени.",
      "register()": "Регистрирует новый кодек."
    },
    "zlib": {
      "compress()": "Сжимает данные.",
      "decompress()": "Разжимает данные.",
      "crc32()": "Вычисляет контрольную сумму CRC32."
    },
    "gzip": {
      "open()": "Открывает gzip-файл для чтения или записи.",
      "GzipFile()": "Класс для работы с gzip-файлами."
    },
    "bz2": {
      "open()": "Открывает bz2-файл для чтения или записи.",
      "BZ2File()": "Класс для работы с bz2-файлами."
    },
    "lzma": {
      "open()": "Открывает lzma-файл для чтения или записи.",
      "LZMAFile()": "Класс для работы с lzma-файлами.",
      "compress()": "Сжимает данные с использованием LZMA.",
      "decompress()": "Разжимает данные, сжатые LZMA."
    },
    "zipfile": {
      "ZipFile()": "Открывает zip-файл для чтения или записи.",
      "ZipInfo()": "Представляет информацию о файле в zip-архиве.",
      "is_zipfile()": "Проверяет, является ли файл zip-архивом."
    },
    "tarfile": {
      "TarFile()": "Открывает tar-файл для чтения или записи.",
      "TarInfo()": "Представляет информацию о файле в tar-архиве.",
      "is_tarfile()": "Проверяет, является ли файл tar-архивом."
    },
    "hashlib": {
      "md5()": "Создает объект MD5 hash.",
      "sha256()": "Создает объект SHA256 hash.",
      "sha512()": "Создает объект SHA512 hash.",
      "update()": "Обновляет hash-объект данными.",
      "hexdigest()": "Возвращает hash в шестнадцатеричном формате.",
      "digest()": "Возвращает hash в виде байтов."
    },
    "hmac": {
      "new()": "Создает объект HMAC.",
      "digest()": "Возвращает дайджест HMAC.",
      "compare_digest()": "Сравнивает два дайджеста HMAC для предотвращения атак по времени."
    },
    "secrets": {
      "token_hex()": "Генерирует случайный шестнадцатеричный токен.",
      "randbelow()": "Возвращает случайное число меньше заданного числа.",
      "choice()": "Выбирает случайный элемент из последовательности."
    },
    "uuid": {
      "uuid4()": "Генерирует случайный UUID (версии 4).",
      "uuid1()": "Генерирует UUID (версии 1), основанный на времени и MAC-адресе.",
      "UUID()": "Создает UUID из строки.",
      "hex": "Атрибут, содержащий UUID в шестнадцатеричном формате.",
      "int": "Атрибут, содержащий UUID в виде целого числа."
    },
    "profile": {
      "Profile()": "Создает объект профилировщика.",
      "run()": "Запускает профилирование кода.",
      "dump_stats()": "Сохраняет результаты профилирования в файл."
    },
    "pstats": {
      "Stats()": "Анализирует данные профилирования.",
      "sort_stats()": "Сортирует данные профилирования по указанному критерию.",
      "print_stats()": "Выводит данные профилирования в консоль.",
      "strip_dirs()": "Удаляет пути к файлам из данных профилирования."
    },
    "venv": {
      "create()": "Создает виртуальное окружение.",
      "EnvBuilder()": "Класс для создания виртуальных окружений с настраиваемыми параметрами."
    },
    "ensurepip": {
      "bootstrap()": "Устанавливает pip в виртуальное окружение."
    },
    "ctypes": {
      "CDLL()": "Загружает динамическую библиотеку (C DLL или shared object).",
      "Structure": "Базовый класс для структур C.",
      "c_int": "Тип для целого числа C (int).",
      "c_char_p": "Тип для строки C (char*).",
      "c_float": "Тип для числа с плавающей точкой C (float).",
      "c_double": "Тип для числа с плавающей точкой двойной точности C (double).",
      "POINTER()": "Создает тип указателя на другой тип C.",
      "cast()": "Приводит указатель C к другому типу."
    },
     "typing": {
        "TYPE_CHECKING": "Константа, указывающая, выполняется ли проверка типов.",
        "cast()": "Приводит значение к указанному типу (только для проверки типов).",
        "NewType()": "Создает новый уникальный тип.",
        "TypeVar()": "Создает переменную типа.",
        "Generic": "Базовый класс для создания обобщенных типов.",
        "List": "Тип для списка.",
        "Tuple": "Тип для кортежа.",
        "Dict": "Тип для словаря.",
        "Set": "Тип для множества.",
        "Optional": "Тип для значения, которое может быть None.",
        "Union": "Тип для значения, которое может быть одним из нескольких типов.",
        "Callable": "Тип для вызываемого объекта (функции, метода).",
        "Any": "Тип, который может быть любым значением.",
        "NoReturn": "Тип, указывающий, что функция никогда не возвращает значение (например, всегда вызывает исключение).",
        "Literal": "Позволяет указать, что переменная может принимать только одно из заданных литеральных значений.",
        "Final": "Указывает, что переменная или атрибут не может быть переопределен в подклассах (начиная с Python 3.8)."
    },
    "codeop": {
      "compile_command()": "Компилирует строку кода Python.  Поддерживает интерактивный ввод кода."
    },
    "dis": {
      "dis()": "Разбирает байт-код Python.",
      "get_instructions()": "Возвращает инструкции байт-кода для функции.",
      "opname": "Список имен операций байт-кода."
    },
    "inspect": {
      "getmembers()": "Возвращает все члены объекта (атрибуты, методы и т.д.).",
      "signature()": "Возвращает сигнатуру функции.  Содержит информацию о параметрах и возвращаемом значении.",
      "getsource()": "Возвращает исходный код функции.",
      "getfile()": "Возвращает имя файла, в котором определен объект.",
      "isclass()": "Проверяет, является ли объект классом.",
      "isfunction()": "Проверяет, является ли объект функцией."
    },
    "traceback": {
      "format_exc()": "Форматирует информацию об исключении в строку.",
      "print_exc()": "Выводит информацию об исключении в стандартный поток ошибок.",
      "extract_stack()": "Возвращает информацию о текущем стеке вызовов."
    },
    "warnings": {
      "warn()": "Выводит предупреждение.",
      "filterwarnings()": "Фильтрует предупреждения.",
      "simplefilter()": "Устанавливает простой фильтр предупреждений."
    },
    "dataclasses": {
      "dataclass()": "Декоратор для создания классов данных.  Автоматически генерирует методы `__init__`, `__repr__`, `__eq__` и другие.",
      "field()": "Функция для определения параметров полей в классе данных.",
      "asdict()": "Преобразует объект класса данных в словарь.",
      "astuple()": "Преобразует объект класса данных в кортеж."
    },
    "graphlib": {
      "TopologicalSorter()": "Сортирует графы топологически.  Полезно для определения порядка выполнения задач, зависящих друг от друга.",
      "add()": "Добавляет узел в граф (метод TopologicalSorter).",
      "prepare()": "Подготавливает граф к сортировке (метод TopologicalSorter).",
      "get_ready()": "Возвращает набор узлов, готовых к обработке (метод TopologicalSorter).",
      "done()": "Удаляет узел из графа, отмечая его как обработанный (метод TopologicalSorter).",
      "is_active()": "Проверяет, активен ли граф (метод TopologicalSorter).",
      "static_order()": "Возвращает итератор, выдающий узлы в топологическом порядке (метод TopologicalSorter)."
    },
    "turtledemo": {
      "__all__": "Список всех демонстрационных примеров в модуле.",
      "main()": "Запускает графическое демо."

    }
    }
  }
}